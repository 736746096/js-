<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //  面试题
        //  js 的垃圾回收机制：针对的是内存说的
        //  说的是：什么样的数据是没用的数据，没用的数据将被销毁，销毁的是堆中的数据
        //  在内存中，分 栈和堆。栈 是系统创建 堆是程序员创建。如果不能合理的分配使用内存，会导致内存泄漏

        //  内存的生命周期：(底层语言)
        //  1：分配你所需要的内存   (分空间)
        //  2：使用配置你所需要的内存(读，写)   (用空间，放东西，取东西)
        //  3：不需要的时候：将其释放(所谓的垃圾回收机制)   (长久不用的东西，计算机会删除)
        //  注意在 js 高级语言中，只有使用分配所需要内存


        //  引用分类

        //  显示引用：一个对象访问另一个对象下的属性
        //  --->    一个对象引用另一个对象
        //  隐式引用：一个对象，通过原型对象访问的属性

        //  对象指的是：GO  AO 函数对象 普通对象

        //  引用计数垃圾收集
        //  --->  关键看，一个对象是否被其他变量所引用(使用)
        //  【零引用】的对象，将被垃圾回收机制回收

        var o = {
            a: {
                b: 2
            }
        };
        // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
        // 很显然，没有一个可以被垃圾收集
        var o2 = o; //  o2 引用 key 为 a 的对象
        o = 1; //  只有 o2 引用 key 为 a 的对象，o 不再引用了
        var oa = o2.a; //  key 为 b 的对象 被 oa 变量和 a 属性引用
        o2 = 'yo'; //  虽然最初的对象现在已经是零引用了，可以被垃圾回收了
                   // 但是它的属性a的对象还在被oa引用，所以还不能回收
        oa = null; // a属性的那个对象现在也是零引用了
                   // 它可以被垃圾回收了

        //  总结：代码从头执行到尾部，如果说这个对象，以及对象中属性，没有被任何全局变量所引用(直接或间接)，那么这个对象就会被回收

        //  循环引用，(学术观点不同)，浏览器底层处理方式不同，ie 6,7 内存泄漏(符合引用计数垃圾算法)，其他浏览器可能用的是 循环引用算法 和 引用技术垃圾算法
    </script>
</body>

</html>